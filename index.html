<html>

  <style>
    body{
      left:0px;
      top:0px;
      margin:0px;
    }
    #currentShader{

      width:100%;
      top:0px;
      position: fixed;
      color:#fff;

    }
  </style>
  <body>

    <div id="currentShader">

    </div>
<script src="lib/three.js"></script>
<script src="lib/jquery.min.js"></script>
<script src="lib/TrackballControls.js"></script>
<script src="lib/MouseMoveControls.js"></script>
<script src="lib/ShaderLoader.js"></script>
<script src="lib/underscore.js"></script>
<script src="lib/dat.gui.min.js"></script>
<script src="lib/GUI.js"></script>

<script src="lib/AudioController.js"></script>
<script src="lib/AudioTexture.js"></script>
<script src="lib/UserAudio.js"></script>
<script src="lib/NormalMapper.js"></script>

<script src="lib/DiffusionRenderer.js" ></script>

<script src="lib/Tween.js"></script>
<script src="SnowflakeGeometry.js"></script>
<script src="HexGrid.js"></script>

<script>

    var scene, camera, renderer , clock;
    var geometry, material, mesh;
    var controls;

    var grower;


    var debugLines , debugPoints , debugMesh;


    var updateSim = true;
    var SIM_SIZE = 512;
    var snowflake;

    var growSpeed = 200;
    var shrinkSpeed = 100;

    var shaders = new ShaderLoader('shaders');

    var gui = new dat.GUI();


    currentShader = -1;
    SIM_SHADERS = [

     // 'image',
      'test1',
      'snowHex1',
      'snowHex2',
      'snowHex3',
      'snowHex4',
      'snowHex5',
      'snowHex6',
      'test3',
      'snowflake1',
      'snowflake2',
      'snowSimplex1',
      'snowSimplex2',
      'snowSimplex3',
      'snowSimplex4',
      'snowSimplex5',
      'snowSimplex6',
      'snowSimplex7',
      'snowSimplex8'

    ]
    shaders.load( 'vs-snow' , 'snow' , 'vertex'   );
    shaders.load( 'fs-snow' , 'snow' , 'fragment' );
    
    shaders.load( 'vs-test1' , 'test1' , 'vertex'   );
    shaders.load( 'fs-test1' , 'test1' , 'fragment' );
    shaders.load( 'vs-debugMesh' , 'debugMesh' , 'vertex'   );
    shaders.load( 'fs-debugMesh' , 'debugMesh' , 'fragment' );
    shaders.load( 'vs-raytrace' , 'raytrace' , 'vertex'   );
    shaders.load( 'fs-raytrace' , 'raytrace' , 'fragment' );

    shaders.load( 'vs-debugPlane' , 'debugPlane' , 'vertex'   );
    shaders.load( 'fs-debugPlane' , 'debugPlane' , 'fragment' );
    
    shaders.load( 'fs-depthToNormal' , 'depthToNormal' , 'fragment' );
    shaders.load( 'fs-hexCorrection' , 'hexCorrection' , 'fragment' );

    for( var i = 0; i < SIM_SHADERS.length; i++ ){

      var s = SIM_SHADERS[i];
      var n = 'ss-' + s;

      shaders.load( n , s , 'simulation' );


    }
    

    shaders.load( 'ss-test1' , 'test1' , 'simulation' );

    shaders.shaderSetLoaded = function(){
      init();
      animate();
    }

   
    var audioController = new AudioController();
    audioController.mute.gain.value = 0;

    var userAudio = new UserAudio( audioController ); 

    var matcap = THREE.ImageUtils.loadTexture( 'img/matcap.jpg' );
    var panoTexture = THREE.ImageUtils.loadTexture( 'img/pano.jpg' );
    var detailNormal = THREE.ImageUtils.loadTexture( 'img/scratch.png' );
    var sim = THREE.ImageUtils.loadTexture( 'img/SF2.png' );
    
    var uniforms = {
      t_sim:{type:"t" , value:sim },
      t_matcap:{type:"t" , value:matcap},
      t_depth:{type:"t" ,value:null },
      t_normal:{type:"t" ,value:null },
      t_audio:{type:"t" , value: audioController.texture },
      t_pano:{type:"t" , value: panoTexture },
      t_detailNormal:{type:"t" , value: detailNormal },
      filled:{type:"f" , value:0},
      time:{type:"f" , value:0 },
      dT:{type:"f" , value:0 },
      debug:{type:"f" , value: 0 },
    }

    //uniforms.t_normal.value.wrapS        = uniforms.t_normal.value.wrapT        = 
	uniforms.t_detailNormal.value.wrapS  = uniforms.t_detailNormal.value.wrapT  = 
	//uniforms.t_depth.value.wrapS         = uniforms.t_depth.value.wrapT         = 
	THREE.RepeatWrapping;

    function init() {


      renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
     
      window.addEventListener( 'resize', onWindowResize , false );
      window.addEventListener( 'keydown', onKeyDown , false );

      document.body.appendChild( renderer.domElement );

     
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .003, 30 );
      camera.position.z = 1;

      controls = new THREE.TrackballControls( camera , renderer.domElement );

      clock = new THREE.Clock();


      var sphere = new THREE.Mesh(
          new THREE.SphereGeometry( 5, 36, 36 ),
          new THREE.MeshBasicMaterial( { map: panoTexture, side: THREE.BackSide } )
      );
      //scene.add(sphere );




      var mat = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: shaders.vs.raytrace,
        fragmentShader: shaders.fs.raytrace,
		shading: THREE.SmoothShading,
		side: THREE.FrontSide,
		depthTest: false,
   		depthWrite: false,

		transparent: true
      });

      console.log( shaders.vs );

      /*var mat = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: shaders.vs.debugPlane,
        fragmentShader: shaders.fs.debugPlane,
		shading: THREE.SmoothShading,
		side: THREE.FrontSide,
		//depthTest: false,
		//depthWrite: false,
		//transparent: true
      });*/
      //var mesh = new THREE.Mesh( geo , mat );

      //scene.add( mesh );


           object = new THREE.Object3D();
      var geometry = new THREE.PlaneGeometry( 2, 2, 100,100 );
     
      mesh = new THREE.Mesh( geometry, mat );
      mesh.geometry.computeTangents();
      object.add( mesh );
      mesh = new THREE.Mesh( geometry, mat );
      /*mesh.geometry.computeTangents();
      mesh.rotation.y = Math.PI;
      object.add( mesh );*/

	  //object.add( mesh );
      //debugMesh.scale.y *= .9;

      object.position.z = .1;
      scene.add( object );

      nextSnowflake();

     /* var ss = shaders.setValue( shaders.ss.test1 , 'SIZE' , SIM_SIZE+"." );
      grower = new DiffusionRenderer( SIM_SIZE , ss , renderer );
      grower.setUniform( 'time' , uniforms.time  );
      grower.setUniform( 'dT' , uniforms.dT  );
      grower.setUniform( 't_audio' , uniforms.t_audio  );

      grower.addBoundTexture( uniforms.t_depth , 'output' );

      resetGrowth();
      resetGrowth();
      resetGrowth();*/
      // uniforms.filled.value = PARAMS.guide.maxDepth*2;

//	renderer.autoClear = false;
      
    }


    function newSnowflake( ss ){

      var ss = shaders.setValue( ss , 'SIZE' , SIM_SIZE+"." );
      
      if( grower ){
        grower.removeDebugScene( scene );
      }
      
      
      grower = new DiffusionRenderer( SIM_SIZE , ss , renderer );
      grower.setUniform( 'time' , uniforms.time  );
      grower.setUniform( 'dT' , uniforms.dT  );

      grower.setUniform( 't_audio' , uniforms.t_audio  );
      grower.setUniform( 't_sim' , uniforms.t_sim  );

      grower.addBoundTexture( uniforms.t_depth , 'output' );
      grower.addBoundTexture( uniforms.t_normal , 'normal' );


      resetGrowth();
      resetGrowth();
      resetGrowth();
      
      
      //grower.addDebugScene( scene );



    }

    function nextSnowflake(){

      var div = document.getElementById( 'currentShader' );
      currentShader++;
      currentShader  %= SIM_SHADERS.length;
      //console.log( currentShader );

    

      var newShader = SIM_SHADERS[ currentShader ];
      div.innerHTML = newShader;
      //console.log( newShader );

      var ss = shaders.ss[ newShader ];
      //console.log( ss );

      newSnowflake( ss );



    }

    function animate() {

      requestAnimationFrame( animate );


      audioController.update();
      controls.update();
      TWEEN.update();

      if( updateSim == true ){

        grower.update();

      }
      uniforms.dT.value = clock.getDelta();
      uniforms.time.value += uniforms.dT.value;
    /*   if( filling == true ){
          uniforms.filled.value += .03;
       }else{
          uniforms.filled.value -= .03;
       }*/

      // object.rotation.y += .001;
      renderer.render( scene, camera );

    }

      // Resets the renderer to be the proper size
    function onWindowResize(){

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();


      renderer.setSize( window.innerWidth, window.innerHeight );
     
      var dpr = devicePixelRatio || 1;

      //camUniforms.SS.value.x = window.innerWidth * dpr;
      //camUniforms.SS.value.y = window.innerHeight * dpr;


    }

    function onKeyDown(e){

      //console.log( e.keyCode );
      if( e.keyCode == 32 ){

        updateSim = !updateSim;

      }

      if( e.keyCode == 49 ){

        debugLines.visible = !debugLines.visible;

      }

      if( e.keyCode == 50 ){

        debugPoints.visible = !debugPoints.visible;

      }
      if( e.keyCode == 51 ){

        debugMesh.visible = !debugMesh.visible;

      }

      if( e.keyCode == 48 ){

        uniforms.debug.value = (uniforms.debug.value + 1) % 4;
       // debugMesh.visible = !debugMesh.visible;

     }

     if( e.keyCode == 39 ){

        nextSnowflake();
        //uniforms.debug.value = (uniforms.debug.value + 1) % 4;
       // debugMesh.visible = !debugMesh.visible;

      }

     console.log( e.keyCode );


   }


    function resetGrowth(){
      var size = SIM_SIZE;
      
      var data = new Float32Array( SIM_SIZE * SIM_SIZE * 4 );

      for( var i = 0; i < data.length; i+=4 ){


        data[ i + 0 ] = 0;
        data[ i + 1 ] = 100;
        data[ i + 2 ] = 0;
        data[ i + 3 ] = 100;

      }

      var texture = new THREE.DataTexture( 
        data,
        size,
        size,
        THREE.RGBAFormat,
        THREE.FloatType
      );

      texture.minFilter =  THREE.NearestFilter,
      texture.magFilter = THREE.NearestFilter,

      texture.needsUpdate = true;

      grower.reset( texture );

   }
  </script>

</body>
</html>
