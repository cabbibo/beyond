<html>

  <style>
    body{
      left:0px;
      top:0px;
      margin:0px;
    }
  </style>
  <body>

<script src="lib/three.js"></script>
<script src="lib/jquery.min.js"></script>
<script src="lib/TrackballControls.js"></script>
<script src="lib/MouseMoveControls.js"></script>
<script src="lib/ShaderLoader.js"></script>
<script src="lib/underscore.js"></script>
<script src="lib/dat.gui.min.js"></script>
<script src="lib/GUI.js"></script>

<script src="lib/AudioController.js"></script>
<script src="lib/AudioTexture.js"></script>
<script src="lib/UserAudio.js"></script>

<script src="lib/DiffusionRenderer.js" ></script>

<script src="lib/Tween.js"></script>
<script src="SnowflakeGeometry.js"></script>
<script src="HexGrid.js"></script>

<script>

    var scene, camera, renderer , clock;
    var geometry, material, mesh;
    var controls;

    var debugLines , debugPoints , debugMesh;


    var updateSim = true;
    var SIM_SIZE = 512;
    var snowflake;

    var growSpeed = 200;
    var shrinkSpeed = 100;

    var shaders = new ShaderLoader('shaders');

    var gui = new dat.GUI();

    shaders.load( 'vs-snow' , 'snow' , 'vertex'   );
    shaders.load( 'fs-snow' , 'snow' , 'fragment' );
    
    shaders.load( 'vs-test1' , 'test1' , 'vertex'   );
    shaders.load( 'fs-test1' , 'test1' , 'fragment' );
    shaders.load( 'vs-debugMesh' , 'debugMesh' , 'vertex'   );
    shaders.load( 'fs-debugMesh' , 'debugMesh' , 'fragment' );


    shaders.load( 'ss-test1' , 'test1' , 'simulation' );

    shaders.shaderSetLoaded = function(){
      init();
      animate();
    }

   
    var audioController = new AudioController();
    audioController.mute.gain.value = 0;

    var userAudio = new UserAudio( audioController ); 

    var matcap = THREE.ImageUtils.loadTexture( 'img/rough-aluminium.jpg' );
    var uniforms = {
      t_matcap:{type:"t" , value:matcap},
      filled:{type:"f" , value:0},
      time:{type:"f" , value:0 },
      dT:{type:"f" , value:0 },
      t_depth:{type:"t" ,value:null },
      debug:{type:"f" , value: 0 },
      t_audio:{type:"t" , value: audioController.texture }
    }


    function init() {


      renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
     
      window.addEventListener( 'resize', onWindowResize , false );
      window.addEventListener( 'keydown', onKeyDown , false );

      document.body.appendChild( renderer.domElement );

     
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .003, 30 );
      camera.position.z = 1;

      controls = new THREE.TrackballControls( camera , renderer.domElement );

      clock = new THREE.Clock();


      var geo = createHexGridGeometry( SIM_SIZE -1);


      var vs = shaders.setValue( shaders.vs.debugMesh , 'SIZE' , SIM_SIZE-1 );
      var mat = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vs,
        fragmentShader: shaders.fs.debugMesh,
        side: THREE.DoubleSide,
        transparent: true
      });
      //var mesh = new THREE.Mesh( geo , mat );

      //scene.add( mesh );


      debugMesh = new THREE.Mesh( geo , mat );

      //debugMesh.scale.y *= .9;

      scene.add( debugMesh);

      var vs = shaders.setValue( shaders.vs.test1 , 'SIZE' , SIM_SIZE-1 );
      var mat = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vs,
        fragmentShader: shaders.fs.test1,
        side: THREE.DoubleSide,
        linewidth:5
      });

      var lineGeo = createHexGridLineGeometry( SIM_SIZE-1 );
      debugLines = new THREE.Line( lineGeo , mat , THREE.LinePieces );
      scene.add( debugLines );
      debugLines.position.z = .001;

      debugLines.visible = false;
      debugPoints = new THREE.PointCloud( geo , mat );
      scene.add(debugPoints);
      debugPoints.position.z = .001;
      debugPoints.visible = false;


      var ss = shaders.setValue( shaders.ss.test1 , 'SIZE' , SIM_SIZE+"." );
      grower = new DiffusionRenderer( SIM_SIZE , ss , renderer );
      grower.setUniform( 'time' , uniforms.time  );
      grower.setUniform( 'dT' , uniforms.dT  );
      grower.setUniform( 't_audio' , uniforms.t_audio  );

      grower.addBoundTexture( uniforms.t_depth , 'output' );

      resetGrowth();
      resetGrowth();
      resetGrowth();
     // uniforms.filled.value = PARAMS.guide.maxDepth*2;
    }

   
    function animate() {

      requestAnimationFrame( animate );


      audioController.update();
      controls.update();
      TWEEN.update();

      if( updateSim == true ){

        grower.update();

      }
      uniforms.dT.value = clock.getDelta();
      uniforms.time.value += uniforms.dT.value;
    /*   if( filling == true ){
          uniforms.filled.value += .03;
       }else{
          uniforms.filled.value -= .03;
       }*/

      renderer.render( scene, camera );

    }

      // Resets the renderer to be the proper size
    function onWindowResize(){

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();


      renderer.setSize( window.innerWidth, window.innerHeight );
     
      var dpr = devicePixelRatio || 1;

      //camUniforms.SS.value.x = window.innerWidth * dpr;
      //camUniforms.SS.value.y = window.innerHeight * dpr;


    }

    function onKeyDown(e){

      if( e.keyCode == 32 ){

        updateSim = !updateSim;

      }

      if( e.keyCode == 49 ){

        debugLines.visible = !debugLines.visible;

      }

      if( e.keyCode == 50 ){

        debugPoints.visible = !debugPoints.visible;

      }
      if( e.keyCode == 51 ){

        debugMesh.visible = !debugMesh.visible;

      }

      if( e.keyCode == 48 ){

        uniforms.debug.value = (uniforms.debug.value + 1) % 4;
       // debugMesh.visible = !debugMesh.visible;

      }

     console.log( e.keyCode );


   }


    function resetGrowth(){
      var size = SIM_SIZE;
      
      var data = new Float32Array( SIM_SIZE * SIM_SIZE * 4 );

      for( var i = 0; i < data.length; i+=4 ){


        data[ i + 0 ] = 0;
        data[ i + 1 ] = 100;
        data[ i + 2 ] = 0;
        data[ i + 3 ] = 100;

      }

      var texture = new THREE.DataTexture( 
        data,
        size,
        size,
        THREE.RGBAFormat,
        THREE.FloatType
      );

      texture.minFilter =  THREE.NearestFilter,
      texture.magFilter = THREE.NearestFilter,

      texture.needsUpdate = true;

      grower.reset( texture );

   }
  </script>

</body>
</html>
