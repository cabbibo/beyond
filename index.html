<html>

  <style>
    body{
      left:0px;
      top:0px;
      margin:0px;
    }
  </style>
  <body>

<script src = "lib/three.js"                  ></script>
<script src = "lib/jquery.min.js"             ></script>
<script src = "lib/TrackballControls.js"      ></script>
<script src = "lib/MouseMoveControls.js"      ></script>
<script src = "lib/ShaderLoader.js"           ></script>
<script src = "lib/underscore.js"             ></script>
<script src = "lib/dat.gui.min.js"            ></script>
<script src = "lib/GUI.js"                    ></script>

<script src = "lib/AudioController.js"        ></script>
<script src = "lib/AudioTexture.js"           ></script>
<script src = "lib/LoadedAudio.js"            ></script>
<script src = "lib/UserAudio.js"              ></script>

<script src = "lib/DiffusionRenderer.js"      ></script>

<script src = "lib/Tween.js"                  ></script>
<script src = "SnowflakeGeometry.js"          ></script>
<script src = "Snowflake.js"                  ></script>
<script src = "HexGrid.js"                    ></script>
<script src = "Choreography.js"               ></script>

<script src = "initSnowflakes.js"             ></script>
<script src = "initChoreography.js"           ></script>
<script src = "initLoadSnowflake.js"          ></script>

<script>


    var scene, camera, renderer , clock;
    var geometry, material, mesh;
    var controls;

    var debugLines , debugPoints , debugMesh;

    var loaded = false;
    var loadSnowflake;

    // Gets a snowflake in so we can keep
    // people entertained while everything loads
    setup();
    animate();



    var updateSim = true;

    // Creates the geometry used, the texture to reset, 
    // by using the simulation size
    var SIM_SIZE      = 512;
    var SNOWFLAKE_GEO = createHexGridGeometry( SIM_SIZE-1 );
    var RESET_TEXTURE = createResetTexture( SIM_SIZE );

    var choreography; 

    var snowflakes = [];


    var shaders = new ShaderLoader('shaders');

    var gui = new dat.GUI();

    shaders.load( 'vs-snow'       , 'snow'        , 'vertex'   );
    shaders.load( 'fs-snow'       , 'snow'        , 'fragment' );
    
    shaders.load( 'vs-test1'      , 'test1'       , 'vertex'   );
    shaders.load( 'fs-test1'      , 'test1'       , 'fragment' );
    shaders.load( 'vs-debugMesh'  , 'debugMesh'   , 'vertex'   );
    shaders.load( 'fs-debugMesh'  , 'debugMesh'   , 'fragment' );


    shaders.load( 'ss-test1'      , 'test1'       , 'simulation' );
    shaders.load( 'ss-snowflake1' , 'snowflake1'  , 'simulation' );


    // Audio should always load after shaders,
    // so lets leave t
    shaders.shaderSetLoaded = function(){
      onLoad(); 
    }

   
    var audioController = new AudioController();
   // audioController.mute.gain.value = 0;

    var audio = new LoadedAudio( audioController , 'audio/beyond.mp3' , {
      texture: false
    });

    audio.firstLoadProgress = false;
    audio.loadProgress = function(){

      if( this.firstLoadProgress === false ){

        console.log( 'FIRST LOADS');
        this.firstLoadProgress = true;
      
      }

      loadSnowflake.material.uniforms.filled.value = this.loaded * 10.;
      console.log( loadSnowflake.material.uniforms.filled );

      console.log( this.loaded );

    }

    audio.onLoad = function(){

      //loadSnowflake.material.uniforms.filled.value = this.loaded;
      console.log( loadSnowflake.material.uniforms.filled );

      onLoad();

    }



   // var userAudio = new UserAudio( audioController ); 

    var matcap  = THREE.ImageUtils.loadTexture( 'img/rough-aluminium.jpg' );
    var aT      = audioController.texture;

    // Our Uniforms!
    // To be used in both simulation, and renderering
    var uniforms = {

      t_matcap:     { type:"t" , value: matcap    },
      t_audio:      { type:"t" , value: aT        },
      t_depth:      { type:"t" , value: null      },
      filled:       { type:"f" , value: 0         },
      time:         { type:"f" , value: 0         },
      dT:           { type:"f" , value: 0         },
      debug:        { type:"f" , value: 0         },

    }

    


    // Before all our shaders / song are loaded
    function setup(){

      renderer = new THREE.WebGLRenderer();
      renderer.setSize( window.innerWidth, window.innerHeight );
     
      window.addEventListener( 'resize', onWindowResize , false );
      window.addEventListener( 'keydown', onKeyDown , false );

      document.body.appendChild( renderer.domElement );
     
      scene   = new THREE.Scene();

      var ar  = window.innerWidth / window.innerHeight;
      camera  = new THREE.PerspectiveCamera( 75, ar , .003, 30 );

      camera.position.z = 1;
      controls = new THREE.TrackballControls( camera , renderer.domElement );

      loadSnowflake = initLoadSnowflake();
      loadSnowflake.scale.multiplyScalar( .004 );
      scene.add( loadSnowflake );

    }

    function init(){


      clock = new THREE.Clock();

      var ss = shaders.ss.test1;
      var vs = shaders.vs.debugMesh;
      var fs = shaders.fs.debugMesh;


      initSnowflakes();
      initChoreography();

      loaded = true;
      
      
      /* var snowflake = new Snowflake( ss , vs , fs );
      snowflakes.push( snowflake );

      snowflake.activate();*/

    }

   
    function animate() {
      requestAnimationFrame( animate );

        controls.update();

      if( loaded == true ){

        audioController.update();
        TWEEN.update();

        uniforms.dT.value = clock.getDelta();
        uniforms.time.value += uniforms.dT.value;

        choreography.update();

        if( updateSim == true ){

          for( var i = 0; i < snowflakes.length; i++ ){

            snowflakes[i].update();

          }

        }

      }


      renderer.render( scene, camera );
      

    }

      // Resets the renderer to be the proper size
    function onWindowResize(){

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();


      renderer.setSize( window.innerWidth, window.innerHeight );
     
      var dpr = devicePixelRatio || 1;

    }

    function onKeyDown(e){

      if( e.keyCode == 32 ){

        updateSim = !updateSim;

      }

      if( e.keyCode == 48 ){

        uniforms.debug.value = (uniforms.debug.value + 1) % 4;

      }


      /*if( e.keyCode == 49 ){

        debugLines.visible = !debugLines.visible;

      }

      if( e.keyCode == 50 ){

        debugPoints.visible = !debugPoints.visible;

      }
      
      if( e.keyCode == 51 ){

        debugMesh.visible = !debugMesh.visible;

      }*/


     console.log( e.keyCode );


   }


   function createResetTexture( size ){

     var data = new Float32Array( size * size * 4 );

      for( var i = 0; i < data.length; i+=4 ){


        data[ i + 0 ] = 0;
        data[ i + 1 ] = 100;
        data[ i + 2 ] = 0;
        data[ i + 3 ] = 100;

      }

      var texture = new THREE.DataTexture( 
        data,
        size,
        size,
        THREE.RGBAFormat,
        THREE.FloatType
      );

      texture.minFilter =  THREE.NearestFilter,
      texture.magFilter = THREE.NearestFilter,

      texture.needsUpdate = true;

      return texture;

   }

   //loaded = ++
   function onLoad(){


   }

 </script>

</body>
</html>
